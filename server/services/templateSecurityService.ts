/**
 * Template Security Service
 * 
 * This service implements security measures to prevent premium users from
 * abusing or monetizing the template generation system.
 */

import crypto from 'crypto';
import { Request } from 'express';
import { storage } from '../storage';

// Template Usage Constants
const DAILY_TEMPLATE_LIMIT = 10;
const MONTHLY_TEMPLATE_LIMIT = 100;

export interface TemplateUsage {
  currentDay: number;
  currentMonth: number;
  remainingToday: number;
  remainingThisMonth: number;
  limitReached: boolean;
}

export interface TemplateSecurityInfo {
  watermarkId: string;
  visibleStatement: string;
  securityCode: string;
}

class TemplateSecurityService {
  
  /**
   * Check if user has reached daily or monthly template generation limits
   */
  async checkUsageLimits(userId: number): Promise<TemplateUsage> {
    // Get the current date and month start date
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const monthStart = new Date();
    monthStart.setDate(1);
    monthStart.setHours(0, 0, 0, 0);
    
    // In a real implementation, we would query the database
    // Since we don't have a template_usage table yet, we'll use a fallback
    // that assumes the user hasn't hit limits
    
    // This is a placeholder for future implementation
    const usageStats = {
      currentDay: 0,
      currentMonth: 0,
      remainingToday: DAILY_TEMPLATE_LIMIT,
      remainingThisMonth: MONTHLY_TEMPLATE_LIMIT,
      limitReached: false
    };
    
    return usageStats;
  }
  
  /**
   * Create watermark and security identifiers for a template
   */
  generateSecurityInfo(
    userId: number,
    userName: string,
    req: Request,
    templateType: string
  ): TemplateSecurityInfo {
    const deviceInfo = req.headers['user-agent'] || 'unknown';
    const clientIp = req.ip || req.socket.remoteAddress || 'unknown';
    const timestamp = Date.now();
    
    // Generate a unique watermark ID
    const watermarkData = `${userId}-${timestamp}-${templateType}-${clientIp}`;
    const watermarkId = crypto.createHash('sha256')
      .update(watermarkData)
      .digest('hex')
      .substring(0, 16);
    
    // Generate a user-visible security statement
    const visibleStatement = `Generated by ATSBoost for ${userName} - ${new Date().toISOString().split('T')[0]} - ID: ${watermarkId}`;
    
    // Generate a shorter verification code
    const securityCode = crypto.createHash('md5')
      .update(watermarkId)
      .digest('hex')
      .substring(0, 8)
      .toUpperCase();
    
    return {
      watermarkId,
      visibleStatement,
      securityCode
    };
  }
  
  /**
   * Apply watermarking to template content
   */
  applyWatermark(content: string, securityInfo: TemplateSecurityInfo): string {
    // Add visible watermark at the end
    const watermarkedContent = `${content}\n\n${securityInfo.visibleStatement}`;
    
    // Embed invisible watermark in whitespace (simplified)
    // In a real system, we would use more sophisticated techniques
    
    return watermarkedContent;
  }
  
  /**
   * Record template generation for tracking and limiting
   */
  async recordTemplateGeneration(
    userId: number,
    templateType: string,
    securityInfo: TemplateSecurityInfo,
    metadata: any
  ): Promise<void> {
    try {
      // Log template generation for audit purposes
      const templateInfo = {
        userId,
        templateType,
        watermarkId: securityInfo.watermarkId,
        securityCode: securityInfo.securityCode,
        timestamp: new Date(),
        metadata
      };
      
      // Use proper production logging
      if (process.env.NODE_ENV === 'production') {
        console.info('Template generated:', JSON.stringify(templateInfo));
      } else {
        console.log(`Template generated for user ${userId}:`, templateInfo);
      }
      
      // TODO: Implement database storage when template_usage table is created
      // For now, we'll continue tracking via logs
    } catch (error) {
      console.error('Error recording template generation:', error);
    }
  }
  
  /**
   * Verify if a template was generated through our system
   * Used to detect unauthorized sharing/distribution
   */
  async verifyTemplate(content: string): Promise<{
    isAuthentic: boolean;
    originalUser?: number;
    generationDate?: Date;
  }> {
    // Extract watermark ID from content (simplified)
    const watermarkMatch = content.match(/ID: ([a-f0-9]{16})/i);
    
    if (!watermarkMatch) {
      return { isAuthentic: false };
    }
    
    const extractedId = watermarkMatch[1];
    
    // In a real implementation, we would look up this ID in our database
    // This is a placeholder implementation
    return {
      isAuthentic: true,
      originalUser: 0, // Placeholder
      generationDate: new Date()
    };
  }
}

export const templateSecurityService = new TemplateSecurityService();