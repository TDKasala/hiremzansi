import { randomBytes, createHash } from 'crypto';
import { db } from '../db';
import { generatedTemplates, users } from '../../shared/schema';
import { eq, and, gte } from 'drizzle-orm';

/**
 * Template Security Service
 * Handles watermarking, usage tracking, and anti-abuse measures
 */

export interface SecurityInfo {
  watermarkId: string;
  securityCode: string;
  timestamp: Date;
  userAgent: string;
  ipAddress: string;
}

export interface UsageStats {
  todayUsage: number;
  monthUsage: number;
  dailyLimit: number;
  monthlyLimit: number;
  limitReached: boolean;
  remainingToday: number;
  remainingThisMonth: number;
}

class TemplateSecurityService {
  
  /**
   * Check usage limits for template generation
   */
  async checkUsageLimits(userId: number): Promise<UsageStats> {
    try {
      const today = new Date();
      const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
      
      // Get user subscription level
      const user = await db.select().from(users).where(eq(users.id, userId)).limit(1);
      const isPremium = user[0]?.role === 'premium';
      
      // Set limits based on subscription
      const dailyLimit = isPremium ? 20 : 5;
      const monthlyLimit = isPremium ? 100 : 20;
      
      // Count today's usage
      const todayUsage = await db.select()
        .from(generatedTemplates)
        .where(and(
          eq(generatedTemplates.userId, userId),
          gte(generatedTemplates.createdAt, startOfDay)
        ));

      // Count this month's usage
      const monthUsage = await db.select()
        .from(generatedTemplates)
        .where(and(
          eq(generatedTemplates.userId, userId),
          gte(generatedTemplates.createdAt, startOfMonth)
        ));

      const todayCount = todayUsage.length;
      const monthCount = monthUsage.length;
      
      return {
        todayUsage: todayCount,
        monthUsage: monthCount,
        dailyLimit,
        monthlyLimit,
        limitReached: todayCount >= dailyLimit || monthCount >= monthlyLimit,
        remainingToday: Math.max(0, dailyLimit - todayCount),
        remainingThisMonth: Math.max(0, monthlyLimit - monthCount)
      };
    } catch (error) {
      console.error('Error checking usage limits:', error);
      return {
        todayUsage: 0,
        monthUsage: 0,
        dailyLimit: 5,
        monthlyLimit: 20,
        limitReached: false,
        remainingToday: 5,
        remainingThisMonth: 20
      };
    }
  }

  /**
   * Generate security information for watermarking
   */
  generateSecurityInfo(userId: number, userName: string, req: any, templateType: string): SecurityInfo {
    const watermarkId = this.generateWatermarkId(userId, templateType);
    const securityCode = this.generateSecurityCode(userId, userName);
    
    return {
      watermarkId,
      securityCode,
      timestamp: new Date(),
      userAgent: req.headers['user-agent'] || 'Unknown',
      ipAddress: req.ip || req.connection.remoteAddress || 'Unknown'
    };
  }

  /**
   * Apply watermark to template content
   */
  applyWatermark(content: string, securityInfo: SecurityInfo): string {
    // Invisible watermark embedded in content
    const watermark = `\n<!-- Generated by Hire Mzansi CV Service - ${securityInfo.watermarkId} - ${securityInfo.timestamp.toISOString()} -->`;
    
    // Add visible footer watermark
    const visibleWatermark = `\n\n---\nGenerated by Hire Mzansi Professional CV Service\nSecurity Code: ${securityInfo.securityCode}\nFor support: support@hiremzansi.co.za`;
    
    return content + watermark + visibleWatermark;
  }

  /**
   * Record template generation for tracking
   */
  async recordTemplateGeneration(
    userId: number, 
    templateType: string, 
    securityInfo: SecurityInfo,
    metadata: any
  ): Promise<void> {
    try {
      await db.insert(generatedTemplates).values({
        userId,
        templateId: securityInfo.watermarkId,
        templateType,
        title: `${templateType} - ${new Date().toLocaleDateString()}`,
        content: '', // Content stored separately for security
        atsScore: 0,
        keywords: metadata.keywords || [],
        saOptimized: true,
        securityCode: securityInfo.securityCode,
        watermarkId: securityInfo.watermarkId,
        userAgent: securityInfo.userAgent,
        ipAddress: securityInfo.ipAddress,
        createdAt: new Date(),
        updatedAt: new Date()
      });
    } catch (error) {
      console.error('Error recording template generation:', error);
    }
  }

  /**
   * Generate unique watermark ID
   */
  private generateWatermarkId(userId: number, templateType: string): string {
    const timestamp = Date.now();
    const data = `${userId}-${templateType}-${timestamp}`;
    return createHash('sha256').update(data).digest('hex').substring(0, 16);
  }

  /**
   * Generate security code for user verification
   */
  private generateSecurityCode(userId: number, userName: string): string {
    const timestamp = Date.now();
    const data = `${userId}-${userName}-${timestamp}`;
    return createHash('md5').update(data).digest('hex').substring(0, 8).toUpperCase();
  }

  /**
   * Validate template authenticity
   */
  async validateTemplate(securityCode: string, watermarkId: string): Promise<boolean> {
    try {
      const template = await db.select()
        .from(generatedTemplates)
        .where(and(
          eq(generatedTemplates.securityCode, securityCode),
          eq(generatedTemplates.watermarkId, watermarkId)
        ))
        .limit(1);

      return template.length > 0;
    } catch (error) {
      console.error('Error validating template:', error);
      return false;
    }
  }

  /**
   * Get template generation analytics
   */
  async getTemplateAnalytics(userId?: number): Promise<any> {
    try {
      const today = new Date();
      const last7Days = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
      const last30Days = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);

      let query = db.select().from(generatedTemplates);
      
      if (userId) {
        query = query.where(eq(generatedTemplates.userId, userId));
      }

      const allTemplates = await query;
      
      const last7DaysTemplates = allTemplates.filter(t => 
        new Date(t.createdAt) >= last7Days
      );
      
      const last30DaysTemplates = allTemplates.filter(t => 
        new Date(t.createdAt) >= last30Days
      );

      // Group by template type
      const templatesByType = allTemplates.reduce((acc, template) => {
        acc[template.templateType] = (acc[template.templateType] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      return {
        totalGenerated: allTemplates.length,
        last7Days: last7DaysTemplates.length,
        last30Days: last30DaysTemplates.length,
        byType: templatesByType,
        averagePerDay: last30DaysTemplates.length / 30,
        peakUsageDays: this.calculatePeakUsage(last30DaysTemplates)
      };
    } catch (error) {
      console.error('Error getting template analytics:', error);
      return {
        totalGenerated: 0,
        last7Days: 0,
        last30Days: 0,
        byType: {},
        averagePerDay: 0,
        peakUsageDays: []
      };
    }
  }

  /**
   * Calculate peak usage days
   */
  private calculatePeakUsage(templates: any[]): string[] {
    const dayCount = templates.reduce((acc, template) => {
      const day = new Date(template.createdAt).toDateString();
      acc[day] = (acc[day] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return Object.entries(dayCount)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([day]) => day);
  }
}

export const templateSecurityService = new TemplateSecurityService();